1  字符定义

ASCII码  符号  字符缩写（全称）                中文名称

13          \r       CR (carriage return)             回车

10          \n      LF (NL line feed, new line)    换行

 

CR：本义是光标定位到行首（本行），即Carriage Return，\r，n表示return

LF：本义是光标跳至下一行（不一定是下一行行首），即Line Feed，\n，n表示newline

 

假设定义

换行+回车：表示光标跳到下一行行首。

对于WINDOWS/UNIX/Linux等主流操作系统，在文本读写时，键盘的回车键（Enter键）等同于：换行+回车。

 

 

2 差异测试

文本读写时，\r和\n在各主流操作系统的差异：

 

WINDOWS系统: \r\n表示换行+回车

例1：

假如通过程序向文件test.txt从首行写入字符序列：\naaa\r\nbb\nb\rccc

那么，通过程序按字符的ascii码读取文本内容的结果：1097979713109898109813999999

使用记事本打开test.txt，文本内容如下：

aaa

bbbccc(此处为光标终点位置)

可见，Windows系统\r\n表示回车+换行，单独的\r或\n在记事本中的显示为不占位的空字符串，不会控制光标的移动。

 

例2：

假如通过程序向文件test.txt从首行写入字符序列：\naaa\r\nbb\nb\rccc\r

那么，通过程序按字符的ascii码读取文本内容的结果：109797971310989810981399999913

使用记事本打开test.txt，文本内容如下：

aaa

bbbccc(此处为光标终点位置)

可见，\r始终显示为不占位的空字符串，无论是在文本的末尾或中间。

 

例3：

假如通过程序向文件test.txt从首行写入字符序列：\naaa\r\nbb\nb\rccc\n

那么，通过程序按字符的ascii码读取文本内容的结果：109797971310989810981399999910

使用记事本打开test.txt，文本内容如下：

aaa

bbbccc

(此处为光标终点位置)

可见，对于win的记事本，当\n在文本末尾时，光标跳到了下一行行首（回车+换行），而文本中间的\n不会。

 

总结

a.Windows平台，\r\n表示换行+回车

b.单独\r仅表示不占位的ASCII字符（空字符），不控制光标的移动；

c.单独\n仅表示不占位的ASCII字符（空字符），不控制光标的移动；

但当\n位于文本内容的末尾时，对于win的记事本，光标会跳到下一行行首，否则\n不控制光标的移动，求大神解释原因！

 

 

UNIX和Linux系统:  \n表示换行+回车

例1：

假如通过程序向文件test从首行写入字符序列：aaa\n\rbbb\rccc

那么，通过程序按字符的ascii码读取文本内容的结果：979797101398989813999999

[root@localhost opt]vi test

aaa

^Mbbb^Mccc

~

[root@localhost opt]cat test

aaa

ccc[root@localhost opt]# 

可见，\n代表回车+换行，\r在Linux文本编辑器显示为^M，\r在Linux文件读取命令cat控制光标移到到本行行首（本义）

 

例2：

假如在例1字符序列后追加一个\n

通过程序向文件test从首行写入字符序列：aaa\n\rbbb\rccc\n

那么，通过程序按字符ascii码读取文本内容的结果：97979710139898981399999910

[root@localhost opt]vi test

aaa

^Mbbb^Mccc

~

说明：对于vi，\n也是换行+回车， 但在字符序列末尾为时，因vi光标显示问题，效果不明显，导致看似和例1一样

[root@localhost opt]cat test

aaa

ccc

[root@localhost opt]# 

 

例3：

假如在例2字符序列后再追加一个\n

通过程序向文件test从首行写入字符序列：aaa\n\rbbb\rccc\n\n

那么，通过程序按字符ascii码读取文本内容的结果：9797971013989898139999991010

[root@localhost opt]vi test

aaa

^Mbbb^Mccc

 

~

[root@localhost opt]# cat test 

aaa

ccc

 

[root@localhost opt]# 

 

总结

a.Linux系统中，\n表示换行+回车

b.对于Linux的文本编辑器vi，\r显示为^M

c.对于Linux的文本读取和显示命令cat，\r控制光标移动到行首（较好地诠释了\r的意义）

 

MAC:  \r表示换行+回车

mac系统没有做相关测试，有兴趣的可以自己测试。

 

 

3 字符历史（引用）

在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。

于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。

这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。

后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。

 

/*======================================*/

\n:  UNIX 系统行末结束符

\r\n: window 系统行末结束符

\r:  MAC OS 系统行末结束符

/*======================================*/

一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。（这也是经常说见到的现象，哈哈，原来是这样的）

 

c++语言编程时（windows系统）\r 就是return 回到 本行 行首 这就会把这一行以前的输出 覆盖掉

如：

int main() {

cout << "hahaha" << "\r" << "xixi" ;

}

 

最后只显示 xixi 而 hahaha 被覆盖了

\n 是回车＋换行 把光标 先移到 行首 然后换到下一行 也就是 下一行的行首拉

int main() {

cout << "hahaha" << "\n" << "xixi" ;

}

则 显示

hahaha

xixi